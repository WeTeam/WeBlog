using System;
using System.Collections.Generic;
using Lucene.Net.Search;
using Sitecore.Data.Items;
using Sitecore.Diagnostics;
using Sitecore.Globalization;
using Sitecore.Modules.WeBlog.Search.Crawlers;
using Sitecore.Modules.WeBlog.Search.Search;
using Sitecore.Search;

namespace Sitecore.Modules.WeBlog.Search
{
    public class Searcher
    {
        /// <summary>
        /// Gets the WeBlog search index
        /// </summary>
        /// <returns>The index as found my the SearchManager</returns>
        protected Index GetSearchIndex()
        {
            return SearchManager.GetIndex(Settings.SearchIndexName);
        }

        /// <summary>
        /// Performs a search in the WeBlog search index, with a sort
        /// </summary>
        /// <typeparam name="T">The type of the items to be returned from the search</typeparam>
        /// <param name="query">The query to execute</param>
        /// <param name="language">The language of items to retrieve</param>
        /// <param name="maximumResults">The maximum number of results</param>
        /// <param name="sortField">The index field to sort on</param>
        /// <returns>An array of search results, or an empty array if there was an issue</returns>
        public T[] Execute<T>(QueryBase query, Language language, int maximumResults, Action<List<T>, Item> func, string sortField, bool reverseSort)
        {
            if (query is CombinedQuery)
            {
                // Add on database
                (query as CombinedQuery).Add(new FieldQuery(Sitecore.Search.BuiltinFields.Database, Sitecore.Context.Database.Name), QueryOccurance.Must);

                // Add language
                var langCode = DatabaseCrawler.TransformLanguageCode(language.Name);
                (query as CombinedQuery).Add(new FieldQuery(Constants.Index.Fields.Language, langCode), QueryOccurance.Must);
            }

            // I have to use Action<T> cause the compiler can't work out how to use implicit operators when T is one of the items classes (generated by CIG)
            var items = new List<T>();

            if (maximumResults > 0)
            {
                var index = GetSearchIndex();
                if (index != null && index.GetDocumentCount() > 0)
                {
                    using (var searchContext = new SortableIndexSearchContext(index))
                    {
                        SearchHits hits;
                        if (!string.IsNullOrEmpty(sortField))
                        {
#if FEATURE_CONTENT_SEARCH
                          var sort = new Lucene.Net.Search.Sort(new SortField(sortField, SortField.STRING, reverseSort));
#else
                          var sort = new Lucene.Net.Search.Sort(sortField, reverseSort);
#endif
                          hits = searchContext.Search(query, sort);
                        }
                        else
                        {
                            hits = searchContext.Search(query);
                        }

                        if (hits != null)
                        {
                            foreach (var result in hits.FetchResults(0, maximumResults))
                            {
                                var item = SearchManager.GetObject(result);
                                if (item != null)
                                    func(items, (Item)item);
                            }
                        }
                    }
                }
                else
                {
                    Log.Warn("WeBlog index was not found or didn't contain any documents", this);
                }
            }

            return items.ToArray();
        }

        /// <summary>
        /// Performs a search in the WeBlog search index, without a sort
        /// </summary>
        public T[] Execute<T>(QueryBase query, Language language, int maximumResults, Action<List<T>, Item> func)
        {
            return Execute<T>(query, language, maximumResults, func, null, false);
        }
    }
}